---
layout      : single
title       : "시간복잡도(time complexity)는 어떻게 계산하는가?"
categories  : prepare-to-post
tag         : [codingtest] 
toc : true
toc_label: "Contents"
toc_icon	: "list"
toc_sticky : True
author_profile : false
sidebar:
    nav : "docs"
---


>  코딩테스트를 준비하면서 어렵다고 느낀 부분은 효율성 검증에서 막혀 통과가 되지 않을때였습니다. 그럴때 고려해야 하는 것이 **시간복잡도(time complexity)**입니다. 이번 포스팅에서는 시간복잡도에 대해서 알아보고자 합니다.

## 📝시간복잡도(time complexity)란?

 우리가 현실에서 사용하는 컴퓨터는 1초에 32억 번 정도의 연산이 가능하다고 합니다. 실제 코딩테스트에서는 일반적으로 **1초당 1억 번의 연산**이 가능하다고 생각하고 문제를 풀어야 한다. 

* 1부터 n까지 더하는 연산을 프로그래밍한다고 생각해봅니다. 다음 두 가지 방법으로 연산을 진행 할 수 있습니다. 

  * 1 + 2 + 3 + ... + n
  * (n + 1)*n/2 (가우스 공식)

   첫번째 방법으로 연산을 수행했을 경우 총 n번의 `+`연산을 수행해야 하지만, `가우스 공식`을 수행했을 경우엔 `*`, `+`, `/` 총 3번의 연산만 수행하면 됩니다. 

 같은 목적의 프로그램을 만들어야 하는 상황에서 보다 더 빨리 실행이 가능한 프로그램을 만들기 위해 `시간복잡도(time complexity)`를 계산하는 것이 필수적입니다.

## 시간복잡도 Big-O 표현법

   알고리즘에서 시간복잡도는 함수의 입력 값이 n일 때 총 연산횟수인 출력은 대문자 `O`를 이용하여 표현합니다. 이를 `시간복잡도 Big-O 표현법`이라고 합니다. 다음은 그 종류입니다.

* 입력값이 n이고 총연산횟수가 n!번 연산일 때 O(n!)
* 입력값이 n이고 총연산횟수가 2<sup>n</sup>번 연산일 때 O(2<sup>n</sup>)
* 입력값이 n이고 총연산횟수가 n<sup>2</sup>번 연산은 O(n<sup>2</sup>)
* 입력값이 n이고 총연산횟수가 n번 연산은 O(n)
* 입력값이 n이고 총연산횟수가 log<sup>n</sup>번 연산은 O(log<sup>n</sup>)
  (log<sup>n</sup>은 지수가 10인 로그값)
* 입력값 n에 상관없이 총연산횟수가 상수(그 값이 변하지 않는 불변량)번 연산은 O(1)

## 시간복잡도가 O(n)인 경우

 입력값 n에 따라 최악의 경우 n번의 연산을 해야하는 경우 `O(n)`으로 나타냅니다.

* 예시
  집합의 크기가 10이고 집합에 들어있는 수가 {3, 1, 4, 2, 7, 6, 9, 8, 10} 입니다. 이 때, 찾고자 하는 수 x를 집합의 왼쪽부터 오른쪽 순으로 하나하나 비교하면 몇번 걸리는 지를 봅니다.

  ![On](/images/2022-04-25-time_complexity/On.png)

  찾고자 하는 수 x가 3일 때, 3은 맨 왼쪽에 있으므로 1 번 만에 찾을 수 있다. 

  찾고자 하는 수 x가 5일 때, 5는 왼쪽에서 7번째에 있으므로 7번 만에 찾을 수 있다. 

  찾고자 하는 수 x가 10일 때, 10은 왼쪽에서 10번째에 있으므로 10번 만에 찾을 수 있다.



## 시간복잡도가 O(log<sup>n</sup>)인 경우

## 시간복잡도가 O(n<sup>2</sup>)인 경우

## 시간복잡도가 O(2<sup>n</sup>)인 경우

## 시간복잡도가 O(n!)인 경우

